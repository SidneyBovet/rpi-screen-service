use crate::api_config::ApiConfig;
use clap::{Arg, Command};
use std::{fs::File, io::BufReader, path::PathBuf};

pub mod api_config {
    // Generated by [`prost-build`]
    include!(concat!(env!("OUT_DIR"), "/api_config.rs"));
    // Generated by [`pbjson-build`]
    include!(concat!(env!("OUT_DIR"), "/api_config.serde.rs"));
}

fn cli() -> Command {
    Command::new("API tester")
        .about("Testing API stuff (and args parsing + proto, really)")
        //.bin_name("api_tester")
        .arg_required_else_help(true)
        .arg(
            //arg!(--"config" "c" <PATH>)
            Arg::new("path")
                .short('c')
                .long("config")
                .value_parser(clap::value_parser!(std::path::PathBuf))
                .help("Path to a JSON config file with API codes"),
        )
}

fn extract_config(path: Option<&PathBuf>) -> Result<ApiConfig, Box<dyn std::error::Error>> {
    // Return early if we don't have a path
    let path = path.ok_or("Missing path")?;
    // Open the file from the given path
    let file = File::open(path)?;
    // Open the file in a buffered reader
    let reader = BufReader::new(file);
    // This needs to known to use the ApiConfig deserializer
    let api_config: ApiConfig = serde_json::from_reader(reader)?;
    Ok(api_config)
}

fn main() {
    let matches = cli().get_matches();
    let config = extract_config(matches.get_one("path")).expect("Error reading config");
    println!("Config loaded: {:#?}", config);
}
