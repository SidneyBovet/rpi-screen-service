// This must be the proto package name
pub mod api_config {
    // Generated by [`prost-build`]
    include!(concat!(env!("OUT_DIR"), "/api_config.rs"));
    // Generated by [`pbjson-build`]
    include!(concat!(env!("OUT_DIR"), "/api_config.serde.rs"));
}

use crate::config_extractor::api_config::ApiConfig;
use clap::ArgMatches;
use clap::{Arg, Command};
use log::info;
use std::{fs::File, io::BufReader, path::PathBuf};

pub fn cli() -> Command {
    Command::new("API tester")
        .about("Testing API stuff (and args parsing + proto, really)")
        //.bin_name("api_tester")
        .arg_required_else_help(true)
        .arg(
            //arg!(--"config" "c" <PATH>)
            Arg::new("path")
                .short('c')
                .long("config")
                .value_parser(clap::value_parser!(std::path::PathBuf))
                .help("Path to a JSON config file with API codes"),
        )
        .arg(
            Arg::new("log_cfg")
            .short('l')
            .long("log_cfg")
            .value_parser(clap::value_parser!(std::path::PathBuf))
            .help("Path to a log4rs YML file to set up logging")
        )
        .arg(
            Arg::new("dummy_client")
                .long("dummy")
                .action(clap::ArgAction::SetTrue)
                .help("Also start a client making a dummy call, then exit"),
        )
}

pub fn extract_config(matches: &ArgMatches) -> Result<ApiConfig, Box<dyn std::error::Error>> {
    // Return early if we don't have a path
    let path: &PathBuf = matches.get_one("path").ok_or("Missing path argument")?;
    // Open the file from the given path
    let file = File::open(path)?;
    // Open the file in a buffered reader
    let reader = BufReader::new(file);
    // This needs to known to use the ApiConfig deserializer, hence the explicit type
    let api_config: ApiConfig = serde_json::from_reader(reader)?;

    Ok(api_config)
}

// This is used only in the server binary, so will issue an analyzer warning
#[allow(dead_code)]
pub fn init_logging(matches: &ArgMatches) -> Result<(), Box<dyn std::error::Error>> {
    let path: &PathBuf = matches.get_one("log_cfg").ok_or("Missing log config path argument")?;
    log4rs::init_file(path, Default::default())?;
    info!("Server started");

    Ok(())
}
